# ğŸš Minishell - Tu Propia Terminal desde Cero

**Minishell** es un proyecto de la escuela 42 que consiste en crear un shell minimalista similar a Bash. Este desafÃ­o pondrÃ¡ a prueba tus conocimientos sobre procesos, seÃ±ales, tuberÃ­as y gestiÃ³n de memoria en C.

## DescripciÃ³n del Proyecto

Tu objetivo es implementar un intÃ©rprete de comandos que permita ejecutar programas, gestionar la entrada y salida estÃ¡ndar y manejar seÃ±ales como un shell real.

### CaracterÃ­sticas Principales

- Mostrar un **prompt interactivo**.
- **Ejecutar comandos** y manejar argumentos.
- Implementar **pipes (**``**)** para conectar la salida de un comando con la entrada de otro.
- Gestionar la **redirecciÃ³n de entrada (**``**) y salida (**``**, **``**)**.
- Manejar **variables de entorno**.
- Implementar algunos **built-ins** (`echo`, `cd`, `pwd`, `export`, `unset`, `env`, `exit`).
- Capturar y manejar **seÃ±ales** (`CTRL+C`, `CTRL+D`, `CTRL+\`).

## CÃ³mo Compilar ğŸš€

Compila el proyecto con:

```bash
make
```

Esto generarÃ¡ un ejecutable llamado `minishell`.

## Uso ğŸ› ï¸

Ejecuta el shell con:

```bash
./minishell
```

Ejemplo de uso dentro del shell:

```sh
$ echo "Hola, mundo"
Hola, mundo
$ ls -la | grep minishell
$ cat archivo.txt > salida.txt
$ exit
```

## Built-ins Implementados ğŸ“œ

| Comando  | DescripciÃ³n                           |
| -------- | ------------------------------------- |
| `echo`   | Imprime texto en la salida estÃ¡ndar.  |
| `cd`     | Cambia de directorio.                 |
| `pwd`    | Muestra el directorio actual.         |
| `export` | Define variables de entorno.          |
| `unset`  | Elimina variables de entorno.         |
| `env`    | Muestra variables de entorno activas. |
| `exit`   | Cierra la terminal.                   |

## Funcionalidades Avanzadas âš¡

- **Manejo de pipes (**``**)**: Permite encadenar comandos como en Bash.
- **RedirecciÃ³n de Entrada y Salida**:
  - `>` para redirigir salida a un archivo (sobreescribe).
  - `>>` para redirigir salida a un archivo (aÃ±ade).
  - `<` para redirigir entrada desde un archivo.
  - `<<` para hacer un here doc
- **SeÃ±ales**:
  - `CTRL+C` para interrumpir un proceso en ejecuciÃ³n.
  - `CTRL+D` para cerrar el shell.
  - `CTRL+\` para finalizar un proceso en ejecuciÃ³n.

## CÃ³mo Manejar Procesos y Pipes ğŸ”„

Minishell debe manejar mÃºltiples procesos y conexiones entre ellos.

Ejemplo de ejecuciÃ³n en C:

```c
pid_t pid = fork();
if (pid == 0) {
    execve("/bin/ls", args, env);
    perror("execve");
    exit(EXIT_FAILURE);
} else {
    waitpid(pid, NULL, 0);
}
```

Para conectar procesos con pipes:

```c
pipe(fd);
pid_t pid1 = fork();
if (pid1 == 0) {
    dup2(fd[1], STDOUT_FILENO);
    close(fd[0]);
    execve("/bin/ls", args, env);
} else {
    pid_t pid2 = fork();
    if (pid2 == 0) {
        dup2(fd[0], STDIN_FILENO);
        close(fd[1]);
        execve("/bin/grep", args2, env);
    }
    close(fd[0]);
    close(fd[1]);
    waitpid(pid1, NULL, 0);
    waitpid(pid2, NULL, 0);
}
```

## Pruebas y Debugging ğŸ§ª

Ejecuta tests bÃ¡sicos:

```bash
echo "Test Minishell" | ./minishell
ls -l | grep minishell
```

Verifica memoria con `valgrind`:

Hay que ignorar los leaks de readline
```bash
@valgrind -s --trace-children=yes --track-fds=yes --track-origins=yes --leak-check=full ./minishell
```


## Recursos Adicionales ğŸ“š

- [DocumentaciÃ³n de ](https://man7.org/linux/man-pages/man2/execve.2.html)[`execve`](https://man7.org/linux/man-pages/man2/execve.2.html)
- [Pipes en C](https://man7.org/linux/man-pages/man2/pipe.2.html)
- [SeÃ±ales en C](https://man7.org/linux/man-pages/man7/signal.7.html)

## Contribuciones ğŸ› ï¸

Â¡SiÃ©ntete libre de mejorar Minishell! Puedes hacer un **fork** y enviar un **pull request** con mejoras en la funcionalidad o la estructura del cÃ³digo.

## Licencia âš–ï¸

Este proyecto estÃ¡ bajo la **licencia MIT**. Puedes usarlo, modificarlo y distribuirlo libremente.

---

Ahora tienes un README profesional y listo para subir a GitHub. Â¡Que comience la magia del shell scripting en C! ğŸšğŸ”¥

